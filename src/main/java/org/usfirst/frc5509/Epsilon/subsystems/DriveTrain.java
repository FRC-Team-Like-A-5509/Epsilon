// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5509.Epsilon.subsystems;

import org.usfirst.frc5509.Epsilon.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    private static final int TIMEOUT_MS = 10;
    private final static double WHEELBASE = 16.5; // Length between the axis'
	private final static double TRACKWIDTH = 23; // length between two motors on same axis
	//23, 16.5
    private final static double RADIUS = Math.sqrt(Math.pow(WHEELBASE, 2) + Math.pow(TRACKWIDTH, 2));
    private final static double MAX_SPEED = .75;
    private final static double ENCODER_TICKS = 256; // amount of point in wheel rotation for encoder assuming 1024
                                                     // encoder
    private final static double ROTATION_RATIO = 4; // rotation ratio for gearing (probably)
    private final static double CONVERT = ENCODER_TICKS * ROTATION_RATIO;
    private final static double PIDP = 12;
    private final static double PIDI = 0.0001;
    private final static double PIDD = 0;
    private final static double PIDF = 0;
	private double convertUsed = 0;
	private int tickLimit = 20;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX frontRightDrive;
    private WPI_TalonSRX backRightDrive;
    private WPI_TalonSRX backLeftDrive;
    private WPI_TalonSRX frontLeftDrive;
    private WPI_TalonSRX frontRightSwerve;
    private WPI_TalonSRX backRightSwerve;
    private WPI_TalonSRX backLeftSwerve;
    private WPI_TalonSRX frontLeftSwerve;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        frontRightDrive = new WPI_TalonSRX(8);
        
        
        
        backRightDrive = new WPI_TalonSRX(7);
        
        
        
        backLeftDrive = new WPI_TalonSRX(2);
        
        
        
        frontLeftDrive = new WPI_TalonSRX(1);
        
        
        
        frontRightSwerve = new WPI_TalonSRX(6);
        
        
        
        backRightSwerve = new WPI_TalonSRX(5);
        
        
        
        backLeftSwerve = new WPI_TalonSRX(4);
        
        
        
        frontLeftSwerve = new WPI_TalonSRX(3);
        
        
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
			
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

	

    public void initTurnMode() {

		frontLeftSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);
		frontRightSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);
		backLeftSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);
		backRightSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);

		readControlValues();
	}

	public void resetTurnEncoders() {
		frontLeftSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		frontRightSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		backLeftSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		backRightSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);

		frontLeftSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		frontRightSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		backLeftSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		backRightSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
	}

    public void writeDefaultValues() {
		SmartDashboard.putNumber("drivetrain_p", PIDP);
		SmartDashboard.putNumber("drivetrain_i", PIDI);
		SmartDashboard.putNumber("drivetrain_d", PIDD);
		SmartDashboard.putNumber("drivetrain_f", PIDF);
		SmartDashboard.putNumber("drivetrain_convert", CONVERT);
    }
    
    public void readControlValues() {

		double p = SmartDashboard.getNumber("drivetrain_p", PIDP);
		double i = SmartDashboard.getNumber("drivetrain_i", PIDI);
		double d = SmartDashboard.getNumber("drivetrain_d", PIDD);
		double f = SmartDashboard.getNumber("drivetrain_f", PIDF);
		this.convertUsed = SmartDashboard.getNumber("drivetrain_convert", CONVERT);

		frontLeftSwerve.config_kP(0, p, TIMEOUT_MS);
		frontLeftSwerve.config_kI(0, i, TIMEOUT_MS);
		frontLeftSwerve.config_kD(0, d, TIMEOUT_MS);
		frontLeftSwerve.config_kF(0, f, TIMEOUT_MS);

		frontRightSwerve.config_kP(0, p, TIMEOUT_MS);
		frontRightSwerve.config_kI(0, i, TIMEOUT_MS);
		frontRightSwerve.config_kD(0, d, TIMEOUT_MS);
		frontRightSwerve.config_kF(0, f, TIMEOUT_MS);

		backLeftSwerve.config_kP(0, p, TIMEOUT_MS);
		backLeftSwerve.config_kI(0, i, TIMEOUT_MS);
		backLeftSwerve.config_kD(0, d, TIMEOUT_MS);
		backLeftSwerve.config_kF(0, f, TIMEOUT_MS);

		backRightSwerve.config_kP(0, p, TIMEOUT_MS);
		backRightSwerve.config_kI(0, i, TIMEOUT_MS);
		backRightSwerve.config_kD(0, d, TIMEOUT_MS);
		backRightSwerve.config_kF(0, f, TIMEOUT_MS);

	}

	public void drive(double rotation, double x, double y) {

		// calculate x/y components for wheels 1 & 3 as thats all that's needed
		double A = x - rotation * (WHEELBASE / RADIUS);
		double B = x + rotation * (WHEELBASE / RADIUS);
		double C = y - rotation * (TRACKWIDTH / RADIUS);
		double D = y + rotation * (TRACKWIDTH / RADIUS);

		double[] speeds = new double[4];
		double[] rotations = new double[4];

		// calculate speed/rotation for each wheel
		speeds[0] = Math.sqrt(Math.pow(B, 2) + Math.pow(C, 2)); //frontright
		rotations[0] = Math.toDegrees(Math.atan2(B, C));

		// System.out.println("Calculated " + rotations[0]);

		speeds[1] = Math.sqrt(Math.pow(B, 2) + Math.pow(D, 2)); //frontleft
		rotations[1] = Math.toDegrees(Math.atan2(B, D));

		speeds[2] = Math.sqrt(Math.pow(A, 2) + Math.pow(D, 2)); // backleft
		rotations[2] = Math.toDegrees(Math.atan2(A, D));

		speeds[3] = Math.sqrt(Math.pow(A, 2) + Math.pow(C, 2)); //backright
		rotations[3] = Math.toDegrees(Math.atan2(A, C));

		int[] ticks = new int[4];

		for (int i = 0; i < 4; i++) {
			rotations[i] *= -1;
			ticks[i] = (int) (rotations[i] * convertUsed / 360.0);

		}

		for (int i = 0; i < 4; i++) {

			SmartDashboard.putNumber("Speed " + i, speeds[i]);
			SmartDashboard.putNumber("Rotations " + i, rotations[i]);
			SmartDashboard.putNumber("Ticks " + i, ticks[i]);

		}

		frontRightSwerve.getClosedLoopError(0);

		// normalize speeds to a good speed;
		speeds = normalizeSpeeds(speeds, x, y);
		
		/*
		if (Math.abs(frontRightSwerve.getClosedLoopError(0)) < tickLimit) {
			SmartDashboard.putNumber("frontRightDriveSet", speeds[0] * MAX_SPEED);
			frontRightDrive.set(speeds[0] * MAX_SPEED);
		}
		else {
			frontRightDrive.set(0);
		}
		if (Math.abs(frontLeftSwerve.getClosedLoopError(0)) < tickLimit) {
			SmartDashboard.putNumber("frontLeftDriveSet", speeds[1] * MAX_SPEED);
			frontLeftDrive.set(speeds[1] * MAX_SPEED);
		}
		else {
			frontLeftDrive.set(0);
		}
		if (Math.abs(backLeftSwerve.getClosedLoopError(0)) < tickLimit) {
			SmartDashboard.putNumber("backLeftDriveSet", speeds[2] * MAX_SPEED);
			backLeftDrive.set(speeds[2] * MAX_SPEED);
		}
		else {
			backLeftDrive.set(0);
		}
		if (Math.abs(backRightSwerve.getClosedLoopError(0)) < tickLimit) {
			SmartDashboard.putNumber("backRightDriveSet", speeds[3] * MAX_SPEED);
			backRightDrive.set(speeds[3] * MAX_SPEED);
		}
		else {
			backRightDrive.set(0);
		}
		*/
		if (
			Math.abs(frontRightDrive.getClosedLoopError(0)) < tickLimit &&
			Math.abs(frontLeftSwerve.getClosedLoopError(0)) < tickLimit &&
			Math.abs(backLeftSwerve.getClosedLoopError(0)) < tickLimit &&
			Math.abs(backRightSwerve.getClosedLoopError(0)) < tickLimit) {

			SmartDashboard.putNumber("frontRightDriveSet", speeds[0] * MAX_SPEED);
			frontRightDrive.set(speeds[0] * MAX_SPEED);
			SmartDashboard.putNumber("frontLeftDriveSet", speeds[1] * MAX_SPEED);
			frontLeftDrive.set(speeds[1] * MAX_SPEED);
			SmartDashboard.putNumber("backLeftDriveSet", speeds[2] * MAX_SPEED);
			backLeftDrive.set(speeds[2] * MAX_SPEED);
			SmartDashboard.putNumber("backRightDriveSet", speeds[3] * MAX_SPEED);
			backRightDrive.set(speeds[3] * MAX_SPEED);

		}
		else{

			backLeftDrive.set(0);

			backRightDrive.set(0);
			frontLeftDrive.set(0);

			frontRightDrive.set(0);



		}
		

		SmartDashboard.putNumber("frontRightSwerveSet", ticks[0]);
		frontRightSwerve.set(ControlMode.Position, ticks[0]);
		SmartDashboard.putNumber("frontLeftSwerveSet", ticks[1]);
		frontLeftSwerve.set(ControlMode.Position, ticks[1]);
		SmartDashboard.putNumber("backLeftSwerveSet", ticks[2]);
		backLeftSwerve.set(ControlMode.Position, ticks[2]);
		SmartDashboard.putNumber("backRightSwerveSet", ticks[3]);
		backRightSwerve.set(ControlMode.Position, ticks[3]);

	}

	public double[] normalizeSpeeds(double[] speeds, double movementX, double movementY) {
		double maxSpeed = speeds[0];
		double minSpeed = speeds[0];
		// find min and max speeds
		for (int i = 1; i < speeds.length; i++) {
			if (speeds[i] > maxSpeed) {
				maxSpeed = speeds[i];
			}
			if (speeds[i] < minSpeed) {
				minSpeed = speeds[i];
			}
		}
		// normalize to fastest speed
		if (maxSpeed > 1) {
			for (int i = 0; i < speeds.length; i++) {
				speeds[i] /= maxSpeed;
			}
		}
		// normalize to fastest speed if negative
		/*
		 * if (minSpeed < -1) { for (int i = 0; i < speeds.length; i++) { speeds[i] /=
		 * minSpeed * -1; } }
		 */

		// get joystick magnitude of distance (faster than joystick.getMagnitude b/c
		// FastMath
		/*
		 * double magnitude = Math.sqrt(Math.pow(movementX, 2) + Math.pow(movementY,
		 * 2)); // make sure magnitude isn't >1 // magnitude is now guaranteed to be 0
		 * <= x <= 1 where x is magnitude if (magnitude > 1) { magnitude = 1; } //
		 * normalize to magnitude for (int i = 0; i < speeds.length; i++) { speeds[i] *=
		 * magnitude; }
		 */
		return speeds;
	}
}
