// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5509.Epsilon.subsystems;

import org.usfirst.frc5509.Epsilon.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc5509.Epsilon.Swerve.*;

/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    private static final int TIMEOUT_MS = 10;
    private final static double WHEELBASE = 16.5; // Length between the axis'
	private final static double TRACKWIDTH = 23; // length between two motors on same axis
	//23, 16.5
    private final static double RADIUS = Math.sqrt(Math.pow(WHEELBASE, 2) + Math.pow(TRACKWIDTH, 2));
    private final static double MAX_SPEED = 1;
    private final static double ENCODER_TICKS = 256; // amount of point in wheel rotation for encoder assuming 1024
                                                     // encoder
    private final static double ROTATION_RATIO = 4; // rotation ratio for gearing (probably)
    private final static double CONVERT = ENCODER_TICKS * ROTATION_RATIO;
    private final static double PIDP = 12;
    private final static double PIDI = 0.0001;
    private final static double PIDD = 0;
    private final static double PIDF = 0;
	private double convertUsed = 0;
	private int tickLimit = 20;

	private SwerveDriveConfig swerveConfig;
	private VectorAngle swerveVector = new VectorAngle();

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonSRX frontRightDrive;
    private WPI_TalonSRX backRightDrive;
    private WPI_TalonSRX backLeftDrive;
    private WPI_TalonSRX frontLeftDrive;
    private WPI_TalonSRX frontRightSwerve;
    private WPI_TalonSRX backRightSwerve;
    private WPI_TalonSRX backLeftSwerve;
    private WPI_TalonSRX frontLeftSwerve;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        frontRightDrive = new WPI_TalonSRX(8);
        
        
        
        backRightDrive = new WPI_TalonSRX(7);
        
        
        
        backLeftDrive = new WPI_TalonSRX(2);
        
        
        
        frontLeftDrive = new WPI_TalonSRX(1);
        
        
        
        frontRightSwerve = new WPI_TalonSRX(6);
        
        
        
        backRightSwerve = new WPI_TalonSRX(5);
        
        
        
        backLeftSwerve = new WPI_TalonSRX(4);
        
        
        
        frontLeftSwerve = new WPI_TalonSRX(3);
        
        
        

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	

		swerveConfig = new SwerveDriveConfig();

		swerveConfig.track_width = TRACKWIDTH;
		
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new Drive());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
			
    }

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

	

    public void initTurnMode() {

		frontLeftSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);
		frontRightSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);
		backLeftSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);
		backRightSwerve.configSelectedFeedbackSensor(FeedbackDevice.Analog);

		readControlValues();
	}

	public void resetTurnEncoders() {
		frontLeftSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		frontRightSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		backLeftSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);
		backRightSwerve.setSelectedSensorPosition(0, 0, TIMEOUT_MS);

		frontLeftSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		frontRightSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		backLeftSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
		backRightSwerve.setIntegralAccumulator(0, 0, TIMEOUT_MS);
	}

    public void writeDefaultValues() {
		SmartDashboard.putNumber("drivetrain_p", PIDP);
		SmartDashboard.putNumber("drivetrain_i", PIDI);
		SmartDashboard.putNumber("drivetrain_d", PIDD);
		SmartDashboard.putNumber("drivetrain_f", PIDF);
		SmartDashboard.putNumber("drivetrain_convert", CONVERT);
    }
    
    public void readControlValues() {

		double p = SmartDashboard.getNumber("drivetrain_p", PIDP);
		double i = SmartDashboard.getNumber("drivetrain_i", PIDI);
		double d = SmartDashboard.getNumber("drivetrain_d", PIDD);
		double f = SmartDashboard.getNumber("drivetrain_f", PIDF);
		this.convertUsed = SmartDashboard.getNumber("drivetrain_convert", CONVERT);

		frontLeftSwerve.config_kP(0, p, TIMEOUT_MS);
		frontLeftSwerve.config_kI(0, i, TIMEOUT_MS);
		frontLeftSwerve.config_kD(0, d, TIMEOUT_MS);
		frontLeftSwerve.config_kF(0, f, TIMEOUT_MS);

		frontRightSwerve.config_kP(0, p, TIMEOUT_MS);
		frontRightSwerve.config_kI(0, i, TIMEOUT_MS);
		frontRightSwerve.config_kD(0, d, TIMEOUT_MS);
		frontRightSwerve.config_kF(0, f, TIMEOUT_MS);

		backLeftSwerve.config_kP(0, p, TIMEOUT_MS);
		backLeftSwerve.config_kI(0, i, TIMEOUT_MS);
		backLeftSwerve.config_kD(0, d, TIMEOUT_MS);
		backLeftSwerve.config_kF(0, f, TIMEOUT_MS);

		backRightSwerve.config_kP(0, p, TIMEOUT_MS);
		backRightSwerve.config_kI(0, i, TIMEOUT_MS);
		backRightSwerve.config_kD(0, d, TIMEOUT_MS);
		backRightSwerve.config_kF(0, f, TIMEOUT_MS);

	}

	public void drive(double rotation, double x, double y) {

		SwerveHeading heading = new SwerveHeading();

		heading.rotation = rotation;
		heading.x = x;
		heading.y = y;

		SwerveDriveResult initialPosition = new SwerveDriveResult();
        initialPosition.getFrontRightModule().setTurnHeadingTicks(frontRightSwerve.getSelectedSensorPosition());
        initialPosition.getFrontLeftModule().setTurnHeadingTicks(frontLeftSwerve.getSelectedSensorPosition());
        initialPosition.getBackRightModule().setTurnHeadingTicks(backRightSwerve.getSelectedSensorPosition());
        initialPosition.getBackLeftModule().setTurnHeadingTicks(backLeftSwerve.getSelectedSensorPosition());

		SwerveDriveResult result = SwerveDriveMath.getDriveValues(swerveConfig, heading, initialPosition);

		frontRightSwerve.getClosedLoopError(0);

		frontRightSwerve.set(result.getFrontRightModule().turnHeadingTicks);
		frontLeftSwerve.set(result.getFrontLeftModule().turnHeadingTicks);
		backLeftSwerve.set(result.getBackLeftModule().turnHeadingTicks);
		backRightSwerve.set(result.getBackRightModule().turnHeadingTicks);

		if (
			Math.abs(frontRightDrive.getClosedLoopError(0)) < tickLimit &&
			Math.abs(frontLeftSwerve.getClosedLoopError(0)) < tickLimit &&
			Math.abs(backLeftSwerve.getClosedLoopError(0)) < tickLimit &&
			Math.abs(backRightSwerve.getClosedLoopError(0)) < tickLimit) {

			SmartDashboard.putNumber("frontRightDriveSet", result.getFrontRightModule().speedPercentage * MAX_SPEED);
			frontRightDrive.set(result.getFrontRightModule().speedPercentage * MAX_SPEED);
			SmartDashboard.putNumber("frontLeftDriveSet", result.getFrontLeftModule().speedPercentage * MAX_SPEED);
			frontLeftDrive.set(result.getFrontLeftModule().speedPercentage * MAX_SPEED);
			SmartDashboard.putNumber("backLeftDriveSet", result.getBackLeftModule().speedPercentage * MAX_SPEED);
			backLeftDrive.set(result.getBackLeftModule().speedPercentage * MAX_SPEED);
			SmartDashboard.putNumber("backRightDriveSet", result.getBackRightModule().speedPercentage * MAX_SPEED);
			backRightDrive.set(result.getBackRightModule().speedPercentage * MAX_SPEED);

		}
		else{

			backLeftDrive.set(0);
			backRightDrive.set(0);
			frontLeftDrive.set(0);
			frontRightDrive.set(0);

		}
		

	}

	public double[] normalizeSpeeds(double[] speeds, double movementX, double movementY) {
		double maxSpeed = speeds[0];
		double minSpeed = speeds[0];
		// find min and max speeds
		for (int i = 1; i < speeds.length; i++) {
			if (speeds[i] > maxSpeed) {
				maxSpeed = speeds[i];
			}
			if (speeds[i] < minSpeed) {
				minSpeed = speeds[i];
			}
		}
		// normalize to fastest speed
		if (maxSpeed > 1) {
			for (int i = 0; i < speeds.length; i++) {
				speeds[i] /= maxSpeed;
			}
		}
		// normalize to fastest speed if negative
		/*
		 * if (minSpeed < -1) { for (int i = 0; i < speeds.length; i++) { speeds[i] /=
		 * minSpeed * -1; } }
		 */

		// get joystick magnitude of distance (faster than joystick.getMagnitude b/c
		// FastMath
		/*
		 * double magnitude = Math.sqrt(Math.pow(movementX, 2) + Math.pow(movementY,
		 * 2)); // make sure magnitude isn't >1 // magnitude is now guaranteed to be 0
		 * <= x <= 1 where x is magnitude if (magnitude > 1) { magnitude = 1; } //
		 * normalize to magnitude for (int i = 0; i < speeds.length; i++) { speeds[i] *=
		 * magnitude; }
		 */
		return speeds;
	}
}
